<!doctype html><html lang=en><head><title>MCP Server 教程：构建高效的模型上下文管理服务 ::
达则兼济天下</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在构建复杂的AI应用，特别是涉及多轮对话、长期任务或个性化用户体验时，**有效地管理和同步模型的状态或“上下文”**是成功的关键。Model Context Protocol (MCP) 旨在提供一套标准化的方法来处理这一挑战。本教程将深入探讨如何设计和构建一个独立、可伸缩的 MCP Server，以及为什么它对现代AI系统至关重要。
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://www.liaol.net/posts/how_to_make_mcp_server/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://www.liaol.net/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://www.liaol.net/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://www.liaol.net/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="MCP Server 教程：构建高效的模型上下文管理服务"><meta name=twitter:description content="在构建复杂的AI应用，特别是涉及多轮对话、长期任务或个性化用户体验时，**有效地管理和同步模型的状态或“上下文”**是成功的关键。Model Context Protocol (MCP) 旨在提供一套标准化的方法来处理这一挑战。本教程将深入探讨如何设计和构建一个独立、可伸缩的 MCP Server，以及为什么它对现代AI系统至关重要。"><meta property="og:title" content="MCP Server 教程：构建高效的模型上下文管理服务"><meta property="og:description" content="在构建复杂的AI应用，特别是涉及多轮对话、长期任务或个性化用户体验时，**有效地管理和同步模型的状态或“上下文”**是成功的关键。Model Context Protocol (MCP) 旨在提供一套标准化的方法来处理这一挑战。本教程将深入探讨如何设计和构建一个独立、可伸缩的 MCP Server，以及为什么它对现代AI系统至关重要。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.liaol.net/posts/how_to_make_mcp_server/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-18T00:00:47+08:00"><meta property="article:modified_time" content="2025-05-18T00:00:47+08:00"><meta property="og:site_name" content="达则兼济天下"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2453465456861242" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-68FSBJF5BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-68FSBJF5BP")</script></head><body class=light-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>达则兼济天下</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/archive>Archive</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/archive>Archive</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>MCP Server 教程：构建高效的模型上下文管理服务</h1><div class=post-meta><time class=post-date>2025-05-18</time></div><div class=post-content><p>在构建复杂的AI应用，特别是涉及多轮对话、长期任务或个性化用户体验时，**有效地管理和同步模型的状态或“上下文”**是成功的关键。Model Context Protocol (MCP) 旨在提供一套标准化的方法来处理这一挑战。本教程将深入探讨如何设计和构建一个独立、可伸缩的 MCP Server，以及为什么它对现代AI系统至关重要。</p><h2 id=什么是-model-context-protocol-mcp>什么是 Model Context Protocol (MCP)?
<a href=#%e4%bb%80%e4%b9%88%e6%98%af-model-context-protocol-mcp class=h-anchor aria-hidden=true>#</a></h2><p>Model Context Protocol (MCP) 不是一个严格的标准，而是一个概念，代表了在分布式或模块化AI系统中，用于<strong>存储、检索、更新和同步AI模型运行状态或会话信息</strong>的一系列约定或接口。这些上下文信息可能包括：</p><ul><li><strong>对话历史</strong>: 用于保持多轮对话的连贯性。</li><li><strong>用户偏好和个性化数据</strong>: 影响模型响应或行为的用户特定信息。</li><li><strong>任务状态</strong>: 在执行复杂、分步任务时记录当前进度。</li><li><strong>外部工具或API调用结果</strong>: 模型在与外部世界交互时获取的数据。</li><li><strong>模型内部状态</strong>: 如果模型本身需要维护一些短期或长期状态。</li></ul><p>一个定义良好的 MCP 协议和实现它的服务器，能够让你的AI系统更加模块化、易于维护和扩展。</p><h2 id=为什么需要一个独立的-mcp-server>为什么需要一个独立的 MCP Server?
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e7%8b%ac%e7%ab%8b%e7%9a%84-mcp-server class=h-anchor aria-hidden=true>#</a></h2><p>将上下文管理从AI模型或应用逻辑中分离出来，构建一个独立的 MCP Server 带来了诸多优势：</p><ol><li><strong>解耦与模块化</strong>: AI模型或服务可以专注于核心的推理和生成能力，而将状态管理交给专业的服务处理。这提高了代码的清晰度和可维护性。</li><li><strong>可伸缩性</strong>: 上下文服务器可以独立于AI模型进行伸缩。当用户量增加时，你可以根据上下文存储和访问的需求来扩展服务器，而不必等比例扩展计算密集型的AI模型服务。</li><li><strong>集中管理与一致性</strong>: 在分布式AI系统中（例如有多个模型实例处理请求），集中式上下文服务器可以确保所有实例访问到的是最新、一致的状态信息。</li><li><strong>持久化与可靠性</strong>: 专业的服务器设计可以提供更好的数据持久性、备份和恢复机制，确保上下文数据不会丢失。</li><li><strong>安全性</strong>: 集中管理上下文使得实施统一的认证、授权和数据加密策略更加容易。</li><li><strong>版本控制与审计</strong>: 独立的服务器可以更容易地实现上下文的版本控制，方便回溯和审计。</li></ol><p>将上下文管理内嵌在每个AI服务实例中会导致状态分散、难以同步，并且随着系统复杂性增加，维护成本指数级上升。</p><h2 id=构建-mcp-server-的核心组件>构建 MCP Server 的核心组件
<a href=#%e6%9e%84%e5%bb%ba-mcp-server-%e7%9a%84%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6 class=h-anchor aria-hidden=true>#</a></h2><p>一个典型的 MCP Server 架构会包含以下关键部分：</p><ol><li><strong>API/接口层</strong>:<ul><li>提供客户端（如你的AI应用、用户界面）与服务器交互的标准化接口。</li><li>常见的选择是 <strong>RESTful API</strong> 或 <strong>gRPC</strong>。RESTful API 简单易懂，适合Web应用；gRPC 基于 Protocol Buffers，效率更高，适合服务间通信。</li><li>核心接口应包括但不限于：<ul><li><code>POST /contexts</code>: 创建新的上下文。</li><li><code>GET /contexts/{id}</code>: 获取指定ID的上下文。</li><li><code>PUT /contexts/{id}</code> 或 <code>PATCH /contexts/{id}</code>: 更新指定ID的上下文。</li><li><code>DELETE /contexts/{id}</code>: 删除指定ID的上下文。</li><li><code>GET /contexts/{id}/history</code>: 获取上下文的历史版本（如果支持）。</li><li><code>POST /contexts/{id}/append</code>: 向现有上下文追加数据（例如，对话轮次）。</li></ul></li></ul></li><li><strong>核心业务逻辑层</strong>:<ul><li>处理来自API层的请求。</li><li>实现上下文的创建、读取、更新、删除（CRUD）操作。</li><li>负责数据格式验证、业务规则检查（例如，上下文大小限制、生命周期管理）。</li><li>处理可能的并发访问和数据一致性问题。</li></ul></li><li><strong>数据存储层</strong>:<ul><li>用于持久化存储上下文数据。选择合适的数据库取决于数据结构、访问模式和伸缩性需求。</li><li><strong>键值存储 (Key-Value Stores)</strong> 如 Redis, Memcached: 适合存储不需复杂查询、需要极低延迟访问的扁平化上下文数据（如缓存）。</li><li><strong>文档数据库 (Document Databases)</strong> 如 MongoDB, Couchbase: 适合存储结构灵活、JSON/BSON 格式的上下文数据，查询能力适中。</li><li><strong>关系型数据库 (Relational Databases)</strong> 如 PostgreSQL, MySQL: 适合存储结构固定、需要复杂关系查询、保证强一致性的上下文数据的。</li><li><strong>图数据库 (Graph Databases)</strong> 如 Neo4j: 如果上下文数据之间存在复杂的关系（例如用户社交图谱影响对话），可以考虑。</li><li>通常会结合使用：例如用 Redis 作为热点上下文的缓存层，用 PostgreSQL 或 MongoDB 作为主存储。</li></ul></li><li><strong>认证与授权层</strong>:<ul><li>保护上下文数据的安全。</li><li><strong>认证</strong>: 验证客户端的身份（例如，API Key, OAuth2 Token, JWT）。</li><li><strong>授权</strong>: 确定经过认证的客户端是否有权限对特定的上下文执行请求的操作（例如，用户A只能访问和修改自己的上下文）。</li></ul></li><li><strong>缓存层 (可选但推荐)</strong>:<ul><li>使用 Redis 或 Memcached 等内存数据库缓存频繁访问的上下文数据，显著提高读取性能。</li></ul></li><li><strong>监控与日志</strong>:<ul><li>记录服务器的运行状态、请求信息、错误日志等，便于故障排查、性能优化和安全审计。</li></ul></li></ol><h2 id=选择合适的技术栈>选择合适的技术栈
<a href=#%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e6%8a%80%e6%9c%af%e6%a0%88 class=h-anchor aria-hidden=true>#</a></h2><p>构建 MCP Server 的技术栈选择非常灵活，取决于你的团队熟悉度、项目需求和性能目标：</p><ul><li><strong>后端语言与框架</strong>:<ul><li><strong>Python</strong>: Flask, FastAPI (高性能), Django (功能全面)。生态丰富，AI领域常用。</li><li><strong>Node.js</strong>: Express, NestJS (企业级)。适合构建高性能的异步I/O服务。</li><li><strong>Go</strong>: Gin, Echo. 编译型语言，性能高，并发处理能力强。</li><li><strong>Java</strong>: Spring Boot. 生态成熟，适合大型企业级应用。</li></ul></li><li><strong>数据库</strong>: PostgreSQL (通用关系型), MySQL (通用关系型), MongoDB (文档), Redis (缓存/KV存储)。</li><li><strong>通信协议</strong>: RESTful API (HTTP/JSON), gRPC (HTTP/2, Protocol Buffers)。</li><li><strong>部署</strong>: Docker, Kubernetes, 云服务 (AWS, GCP, Azure)。</li></ul><h2 id=实施步骤概要>实施步骤概要
<a href=#%e5%ae%9e%e6%96%bd%e6%ad%a5%e9%aa%a4%e6%a6%82%e8%a6%81 class=h-anchor aria-hidden=true>#</a></h2><ol><li><strong>需求分析与上下文建模</strong>: 明确你的AI应用需要哪些上下文信息，以及这些信息的结构和生命周期。定义清晰的上下文数据模型。</li><li><strong>数据库选型与 Schema 设计</strong>: 根据上下文模型选择合适的数据库，并设计数据库表或集合结构。</li><li><strong>API 接口设计</strong>: 详细设计 RESTful 或 gRPC 接口的端点、请求/响应格式、错误码等。</li><li><strong>后端服务开发</strong>:<ul><li>使用选定的语言和框架实现 API 接口。</li><li>编写业务逻辑，处理上下文的 CRUD 操作。</li><li>集成数据库访问层。</li><li>实现认证和授权逻辑。</li></ul></li><li><strong>缓存集成 (如果需要)</strong>: 添加缓存层，优化读取性能。</li><li><strong>单元测试与集成测试</strong>: 编写测试用例确保服务器功能的正确性。</li><li><strong>部署</strong>: 将服务器打包（如 Docker 镜像）并部署到生产环境。</li><li><strong>监控与告警</strong>: 设置日志收集和性能监控，配置关键指标的告警。</li><li><strong>安全性加固</strong>: 审查代码，确保数据传输和存储的安全性。</li></ol><h2 id=示例伪代码---基于-fastapi-和-redis>示例（伪代码 - 基于 FastAPI 和 Redis）
<a href=#%e7%a4%ba%e4%be%8b%e4%bc%aa%e4%bb%a3%e7%a0%81---%e5%9f%ba%e4%ba%8e-fastapi-%e5%92%8c-redis class=h-anchor aria-hidden=true>#</a></h2><p>这里提供一个使用 FastAPI (Python) 和 Redis 构建简单 MCP Server 的伪代码示例，展示核心的创建和读取功能：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 伪代码示例 (FastAPI + Redis)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> fastapi <span style=color:#f92672>import</span> FastAPI, HTTPException
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic <span style=color:#f92672>import</span> BaseModel
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> redis
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> json <span style=color:#75715e># Redis存储JSON字符串</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 连接到 Redis (假设 Redis 运行在 localhost:6379)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 在生产环境中，需要从配置加载连接信息，并处理连接错误</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> redis<span style=color:#f92672>.</span>Redis(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;localhost&#39;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>6379</span>, db<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, decode_responses<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>ping() <span style=color:#75715e># 检查连接</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Connected to Redis successfully!&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> redis<span style=color:#f92672>.</span>exceptions<span style=color:#f92672>.</span>ConnectionError <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Could not connect to Redis: </span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># 在实际应用中，你可能需要更健壮的错误处理，例如重试或退出</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ContextData</span>(BaseModel):
</span></span><span style=display:flex><span>    data: dict <span style=color:#75715e># 假设上下文数据是JSON格式的字典</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.post</span>(<span style=color:#e6db74>&#34;/contexts/</span><span style=color:#e6db74>{context_id}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_context</span>(context_id: str, context: ContextData):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> r<span style=color:#f92672>.</span>exists(context_id):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> HTTPException(status_code<span style=color:#f92672>=</span><span style=color:#ae81ff>400</span>, detail<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Context already exists&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        r<span style=color:#f92672>.</span>set(context_id, json<span style=color:#f92672>.</span>dumps(context<span style=color:#f92672>.</span>data))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;Context created&#34;</span>, <span style=color:#e6db74>&#34;id&#34;</span>: context_id}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> HTTPException(status_code<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span>, detail<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Failed to create context: </span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.get</span>(<span style=color:#e6db74>&#34;/contexts/</span><span style=color:#e6db74>{context_id}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_context</span>(context_id: str):
</span></span><span style=display:flex><span>    context_data <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>get(context_id)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> context_data <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> HTTPException(status_code<span style=color:#f92672>=</span><span style=color:#ae81ff>404</span>, detail<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Context not found&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#34;id&#34;</span>: context_id, <span style=color:#e6db74>&#34;data&#34;</span>: json<span style=color:#f92672>.</span>loads(context_data)}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> json<span style=color:#f92672>.</span>JSONDecodeError:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> HTTPException(status_code<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span>, detail<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Failed to decode context data&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> HTTPException(status_code<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span>, detail<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Failed to get context: </span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... 可以继续添加 PUT, DELETE 等接口</span>
</span></span></code></pre></div><h2 id=总结与展望>总结与展望
<a href=#%e6%80%bb%e7%bb%93%e4%b8%8e%e5%b1%95%e6%9c%9b class=h-anchor aria-hidden=true>#</a></h2><p>构建一个独立、高效的 Model Context Protocol Server 是提升现代AI应用架构健壮性、可伸缩性和可维护性的重要一步。通过标准化上下文管理，你可以更好地支持复杂的AI交互，并为未来的功能扩展（如多模态上下文、跨会话上下文等）奠定基础。</p><p>希望这篇更详细的教程能帮助你更好地理解和构建自己的模型上下文管理服务！</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://www.liaol.net/posts/linux-remote-pbcopy/><span class=button__text>Linux 远程复制到 macOS 剪贴板</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://giscus.app/client.js data-repo=liaol/liaol.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyNDI2NTY1OA==" data-category=Announcements data-category-id=DIC_kwDOAXJDus4CbdX8 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>达则兼济天下</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>